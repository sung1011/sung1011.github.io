<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Basic on My New Hugo Site</title>
    <link>http://example.org/tags/basic/</link>
    <description>Recent content in Basic on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="http://example.org/tags/basic/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Lock</title>
      <link>http://example.org/2017-04-01-lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/2017-04-01-lock/</guid>
      <description>#lock
悲观锁(Pessimistic Lock): 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
乐观锁(Optimistic Lock): 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。 乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。
两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。 但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</description>
    </item>
    
    <item>
      <title>Scale</title>
      <link>http://example.org/2017-04-03-scale/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/2017-04-03-scale/</guid>
      <description>Scale 1英文字符(word,字符) = 2byte;[ASCII, Unicode, UTF-8]
1中文字符 = 2byte(B) [ASCII,Unicode];
1中文字符 = 3byte(B) [UTF-8];
1B(byte，字节) = 8 bit(见下文);
1KB(Kibibyte，千字节) = 1024B = 2^10 B;
1MB(Mebibyte，兆字节，百万字节，简称“兆”) = 1024KB = 2^20 B;
1GB(Gigabyte，吉字节，十亿字节，又称“千兆”) = 1024MB = 2^30 B;
1TB(Terabyte，万亿字节，太字节) = 1024GB = 2^40 B;
1PB(Petabyte，千万亿字节，拍字节) = 1024TB = 2^50 B;
1EB(Exabyte，百亿亿字节，艾字节) = 1024PB = 2^60 B;
1ZB(Zettabyte，十万亿亿字节，泽字节) = 1024EB = 2^70 B;
1YB(Yottabyte，一亿亿亿字节，尧字节) = 1024ZB = 2^80 B;
1BB(Brontobyte，一千亿亿亿字节) = 1024YB = 2^90 B;</description>
    </item>
    
  </channel>
</rss>