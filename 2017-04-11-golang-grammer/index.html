<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.40.3" />



<link rel="canonical" href="https://sung1011.github.io/2017-04-11-golang-grammer/">


    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <title>golang-grammer - tickles</title>
    
<meta name="description" content="golang语法">

<meta property="og:title" content="golang-grammer - tickles">
<meta property="og:type" content="article">
<meta property="og:url" content="https://sung1011.github.io/2017-04-11-golang-grammer/">
<meta property="og:image" content="https://sung1011.github.io/images/default.png">
<meta property="og:site_name" content="tickles">
<meta property="og:description" content="golang语法">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="tickles">
<meta name="twitter:url" content="https://sung1011.github.io/2017-04-11-golang-grammer/">
<meta name="twitter:title" content="golang-grammer - tickles">
<meta name="twitter:description" content="golang语法">
<meta name="twitter:image" content="https://sung1011.github.io/images/default.png">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"https://sung1011.github.io/"
    },
    "headline": "golang-grammer - tickles",
    "image": {
      "@type": "ImageObject",
      "url": "https://sung1011.github.io/images/default.png",
      "height": 800,
      "width": 800
    },
    "datePublished": "2017-04-11T00:00:00JST",
    "dateModified": "2017-04-11T00:00:00JST",
    "author": {
      "@type": "Person",
      "name": "tickles"
    },
    "publisher": {
      "@type": "Organization",
      "name": "tickles",
      "logo": {
        "@type": "ImageObject",
        "url": "https://sung1011.github.io/images/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": "golang语法"
  }
</script>


    <link href="https://sung1011.github.io/css/styles.css" rel="stylesheet">
    

  </head>

  <body>
    
    
    

    <header class="l-header">
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://sung1011.github.io/">tickles</a>
          </div>

          

        </div>
      </nav>
    </header>

    <main>
      <div class="container">
        
<div class="row">
  <div class="col-md-8">

    <nav class="p-crumb">
      <ol class="breadcrumb">
        <li><a href="https://sung1011.github.io/"><i class="fa fa-home" aria-hidden="true"></i></a></li>
        
        <li class="active">golang-grammer</li>
      </ol>
    </nav>

    <article class="single">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2017-04-11T00:00:00JST">Apr 11, 2017</time></li>
      
      
    </ul>

    <h1 class="title">golang-grammer</h1>
  </header>

  

  <div class="article-body">

<p><strong>Go基础语法，方便查阅</strong></p>

<h5 id="包-变量和函数-https-link-jianshu-com-t-https-tour-go-zh-org-basics"><a href="https://link.jianshu.com?t=https://tour.go-zh.org/basics">包、变量和函数</a></h5>

<ul>
<li><strong>学习 Go 程序的基本组件</strong></li>
</ul>

<h5 id="1-包">1.包</h5>

<ul>
<li>每个 Go 程序都是由包组成的。</li>
<li>程序运行的入口是包 main。</li>
<li>这个程序使用并导入了包 &ldquo;fmt&rdquo; 和 &ldquo;math/rand&rdquo; 。</li>
<li>按照惯例，包名与导入路径的最后一个目录一致。例如，&rdquo;math/rand&rdquo; 包由 package rand 语句开始。</li>

<li><p><strong>注意</strong>：这个程序的运行环境是确定性的，因此 rand.Intn每次都会返回相同的数字。 （为了得到不同的随机数，需要提供一个随机数种子，参阅 <a href="https://link.jianshu.com?t=https://go-zh.org/pkg/math/rand/#Seed">rand.Seed</a>。）</p>

<p>package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math/rand&rdquo;
)</p>

<p>func main() {
    fmt.Println(&ldquo;My favorite number is&rdquo;, rand.Intn(10))
}
`</pre></p></li>

<li><p>结果
<pre><code>My favorite number is 1
</code></pre></p>

<hr />

<h5 id="2-导入">2.导入</h5></li>

<li><p>这个代码用圆括号组合了导入，这是“打包”导入语句。</p></li>

<li><p>同样可以编写多个导入语句，例如：
<pre><code>import &quot;fmt&quot;
import &quot;math&quot;
</code></pre></p></li>

<li><p>不过使用打包的导入语句是更好的形式。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math&rdquo;
)</p>

<p>func main() {
    fmt.Printf(&ldquo;Now you have %g problems.&rdquo;, math.Sqrt(7))
}
`</pre></p></li>

<li><p>结果
<pre><code>Now you have 2.6457513110645907 problems.
</code></pre></p>

<hr />

<h5 id="3-导出名">3.导出名</h5></li>

<li><p>在 Go 中，首字母大写的名称是被导出的。</p></li>

<li><p>在导入包之后，你只能访问包所导出的名字，任何未导出的名字是不能被包外的代码访问的。</p></li>

<li><p>Foo 和 FOO 都是被导出的名称。名称 foo是不会被导出的。执行代码，注意编译器报的错误。然后将 math.pi改名为 math.Pi再试着执行一下。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math&rdquo;
)</p>

<p>func main() {
    fmt.Println(math.pi)
}
`</pre></p></li>

<li><p>结果
<pre><code>tmp/sandbox583763709/main.go:9: cannot refer to unexported name math.pi
tmp/sandbox583763709/main.go:9: undefined: math.pi
</code></pre></p>

<hr />

<h5 id="4-函数">4.函数</h5></li>

<li><p>函数可以没有参数或接受多个参数。</p></li>

<li><p>在这个例子中， add接受两个 int类型的参数。</p></li>

<li><p>注意类型在变量名 <em>之后</em> 。</p></li>

<li><p>（参考 <a href="https://link.jianshu.com?t=https://blog.go-zh.org/gos-declaration-syntax">这篇关于 Go 语法定义的文章</a>了解类型以这种形式出现的原因。）
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func add(x int, y int) int {
    return x + y
}</p>

<p>func main() {
    fmt.Println(add(42, 13))
}
`</pre></p></li>

<li><p>结果
<pre><code>55
</code></pre></p>

<hr />

<h5 id="5-函数-续">5.函数（续）</h5></li>

<li><p>当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。</p></li>

<li><p>在这个例子中 ，
<pre><code>x int, y int
</code></pre></p>

<p>被缩写为</p>

<pre>`x, y int
`</pre>
<pre>`package main

import "fmt"

func add(x, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(42, 13))
}
`</pre></li>

<li><p>结果
<pre><code>55
</code></pre></p>

<hr />

<h5 id="6-多值返回">6.多值返回</h5></li>

<li><p>函数可以返回任意数量的返回值。</p></li>

<li><p><code>swap</code>函数返回了两个字符串。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func swap(x, y string) (string, string) {
    return y, x
}</p>

<p>func main() {
    a, b := swap(&ldquo;hello&rdquo;, &ldquo;world&rdquo;)
    fmt.Println(a, b)
}
`</pre></p></li>

<li><p>结果
<pre><code>world hello
</code></pre></p>

<hr />

<h5 id="7-命名返回值">7.命名返回值</h5></li>

<li><p>Go 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。</p></li>

<li><p>返回值的名称应当具有一定的意义，可以作为文档使用。</p></li>

<li><p>没有参数的 return语句返回各个返回变量的当前值。这种用法被称作“裸”返回。</p></li>

<li><p>直接返回语句仅应当用在像下面这样的短函数中。在长的函数中它们会影响代码的可读性。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}</p>

<p>func main() {
    fmt.Println(split(17))
}
`</pre></p></li>

<li><p>结果
<pre><code>7 10
</code></pre></p>

<hr />

<h5 id="8-变量">8.变量</h5></li>

<li><p>var 语句定义了一个变量的列表；跟函数的参数列表一样，类型在后面。</p></li>

<li><p>就像在这个例子中看到的一样， var 语句可以定义在包或函数级别。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>var c, python, java bool</p>

<p>func main() {
    var i int
    fmt.Println(i, c, python, java)
}
`</pre></p></li>

<li><p>结果
<pre><code>0 false false false
</code></pre></p>

<hr />

<h5 id="9-初始化变量">9.初始化变量</h5></li>

<li><p>变量定义可以包含初始值，每个变量对应一个。</p></li>

<li><p>如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>var i, j int = 1, 2</p>

<p>func main() {
    var c, python, java = true, false, &ldquo;no!&rdquo;
    fmt.Println(i, j, c, python, java)
}
`</pre></p></li>

<li><p>结果
<pre><code>1 2 true false no!
</code></pre></p>

<hr />

<h5 id="10-短声明变量">10.短声明变量</h5></li>

<li><p>在函数中， :=简洁赋值语句在明确类型的地方，可以用于替代 var
定义。</p></li>

<li><p>函数外的每个语句都必须以关键字开始（ var、 func、等等）， :=结构不能使用在函数外
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    var i, j int = 1, 2
    k := 3
    c, python, java := true, false, &ldquo;no!&rdquo;</p>

<pre><code>fmt.Println(i, j, k, c, python, java)
</code></pre>

<p>}
`</pre></p></li>

<li><p>结果
<pre><code>1 2 3 true false no!
</code></pre></p>

<hr />

<h5 id="11-基本类型">11.基本类型</h5></li>

<li><p>Go 的基本类型有Basic types</p></li>

<li><p>bool</p></li>

<li><p>string</p></li>

<li><p>int int8 int16 int32 int64</p></li>

<li><p>uint uint8 uint16 uint32 uint64 uintptr</p></li>

<li><p>byte // uint8 的别名</p></li>

<li><p>rune // int32 的别名</p></li>

<li><p>// 代表一个Unicode码</p></li>

<li><p>float32 float64</p></li>

<li><p>complex64 complex128</p></li>

<li><p>这个例子演示了具有不同类型的变量。 同时与导入语句一样，变量的定义“打包”在一个语法块中。</p></li>

<li><p>int，uint 和 uintptr类型在32位的系统上一般是32位，而在64位系统上是64位。当你需要使用一个整数类型时，你应该首选 int，仅当有特别的理由才使用定长整数类型或者无符号整数类型。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math/cmplx&rdquo;
)</p>

<p>var (
    ToBe   bool       = false
    MaxInt uint64     = 1&lt;&lt;64 - 1
    z      complex128 = cmplx.Sqrt(-5 + 12i)
)</p>

<p>func main() {
    const f = &ldquo;%T(%v)\n&rdquo;
    fmt.Printf(f, ToBe, ToBe)
    fmt.Printf(f, MaxInt, MaxInt)
    fmt.Printf(f, z, z)
}
`</pre></p></li>

<li><p>结果
<pre><code>bool(false)
uint64(18446744073709551615)
complex128((2+3i))
</code></pre></p>

<hr />

<h5 id="12-类型转换">12.类型转换</h5></li>

<li><p>表达式 T(v)将值 v 转换为类型 T 。</p></li>

<li><p>一些关于数值的转换：</p></li>

<li><p>var i int = 42</p></li>

<li><p>var f float64 = float64(i)</p></li>

<li><p>var u uint = uint(f)</p></li>

<li><p>或者，更加简单的形式：</p></li>

<li><p>i := 42</p></li>

<li><p>f := float64(i)</p></li>

<li><p>u := uint(f)</p></li>

<li><p>与 C 不同的是 Go 的在不同类型之间的项目赋值时需要显式转换。 试着移除例子中 float64 或 int 的转换看看会发生什么。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math&rdquo;
)</p>

<p>func main() {
    var x, y int = 3, 4
    var f float64 = math.Sqrt(float64(x*x + y*y))
    var z uint = uint(f)
    fmt.Println(x, y, z)
}
`</pre></p></li>

<li><p>结果
<pre><code>3 4 5
</code></pre></p>

<hr />

<h5 id="13-零值">13.零值</h5></li>

<li><p>变量在定义时没有明确的初始化时会赋值为 <em>零值</em> 。</p></li>

<li><p>零值是：</p></li>

<li><p>数值类型为 0，</p></li>

<li><p>布尔类型为 false ，</p></li>

<li><p>字符串为 &ldquo;&ldquo;（空字符串）。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    var i int
    var f float64
    var b bool
    var s string
    fmt.Printf(&ldquo;%v %v %v %q\n&rdquo;, i, f, b, s)
}
`</pre></p></li>

<li><p>结果
<pre><code>0 0 false &quot;&quot;
</code></pre></p>

<hr />

<h5 id="14-类型推导">14.类型推导</h5></li>

<li><p>在定义一个变量却并不显式指定其类型时（使用 :=语法或者 var =表达式语法）， 变量的类型由（等号）右侧的值推导得出。</p></li>

<li><p>当右值定义了类型时，新变量的类型与其相同：
<pre><code>var i int
    j := i // j 也是一个 int
</code></pre></p></li>

<li><p>但是当右边包含了未指名类型的数字常量时，新的变量就可能是 int、 float64或 complex128。 这取决于常量的精度：
<pre><code>i := 42 // int
    f := 3.142 // float64
    g := 0.867 + 0.5i // complex128
</code></pre></p></li>

<li><p>尝试修改演示代码中 v的初始值，并观察这是如何影响其类型的。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    v := 42 // change me!
    fmt.Printf(&ldquo;v is of type %T\n&rdquo;, v)
}
`</pre></p></li>

<li><p>结果
<pre><code>v is of type int
</code></pre></p>

<hr />

<h5 id="15-常量">15.常量</h5></li>

<li><p>常量的定义与变量类似，只不过使用 const关键字。</p></li>

<li><p>常量可以是字符、字符串、布尔或数字类型的值。</p></li>

<li><p>常量不能使用 :=语法定义。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>const Pi = 3.14</p>

<p>func main() {
    const World = &ldquo;世界&rdquo;
    fmt.Println(&ldquo;Hello&rdquo;, World)
    fmt.Println(&ldquo;Happy&rdquo;, Pi, &ldquo;Day&rdquo;)</p>

<pre><code>const Truth = true
fmt.Println(&quot;Go rules?&quot;, Truth)
</code></pre>

<p>}
`</pre></p></li>

<li><p>结果
<pre><code>Hello 世界
Happy 3.14 Day
Go rules? true
</code></pre></p>

<hr />

<h5 id="16-数值常量">16.数值常量</h5></li>

<li><p>数值常量是高精度的 <em>值</em> 。</p></li>

<li><p>一个未指定类型的常量由上下文来决定其类型。</p></li>

<li><p>也尝试一下输出<code>needInt(Big)</code>吧。</p></li>

<li><p>（int可以存放最大64位的整数，根据平台不同有时会更少。）
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>const (
    Big   = 1 &lt;&lt; 100
    Small = Big &gt;&gt; 99
)</p>

<p>func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
    return x * 0.1
}</p>

<p>func main() {
    fmt.Println(needInt(Small))
    fmt.Println(needFloat(Small))
    fmt.Println(needFloat(Big))
}
`</pre></p></li>

<li><p>结果
<pre><code>21
0.2
1.2676506002282295e+29
</code></pre></p>

<hr />

<hr />

<hr />

<h5 id="流程控制语句-for-if-else-switch-和-defer-https-link-jianshu-com-t-https-tour-go-zh-org-flowcontrol"><a href="https://link.jianshu.com?t=https://tour.go-zh.org/flowcontrol">流程控制语句：for、if、else 、switch 和 defer</a></h5></li>

<li><p>学习如何用条件、循环、开关和推迟语句控制代码的流程。</p>

<h5 id="1-for">1.for</h5></li>

<li><p>Go 只有一种循环结构—— for循环。</p></li>

<li><p>基本的 for循环包含三个由分号分开的组成部分：</p></li>

<li><p>初始化语句：在第一次循环执行前被执行</p></li>

<li><p>循环条件表达式：每轮迭代开始前被求值</p></li>

<li><p>后置语句：每轮迭代后被执行</p></li>

<li><p>初始化语句一般是一个短变量声明，这里声明的变量仅在整个 for循环语句可见。</p></li>

<li><p>如果条件表达式的值变为 false，那么迭代将终止。</p></li>

<li><p>_注意_：不像 C，Java，或者 Javascript 等其他语言，for语句的三个组成部分 并不需要用括号括起来，但循环体必须用 { }括起来。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    sum := 0
    for i := 0; i &lt; 10; i++ {
        sum += i
    }
    fmt.Println(sum)
}
`</pre></p></li>

<li><p>结果
<pre><code>45
</code></pre></p>

<hr />

<h5 id="2-for-续">2.for（续）</h5></li>

<li><p>循环初始化语句和后置语句都是可选的。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    sum := 1
    for ; sum &lt; 1000; {
        sum += sum
    }
    fmt.Println(sum)
}
`</pre></p></li>

<li><p>结果
<pre><code>1024
</code></pre></p>

<hr />

<h5 id="3-for-是-go-的-while">3.for 是 Go 的 “while”</h5></li>

<li><p>基于此可以省略分号：C 的 while在 Go 中叫做 for。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    sum := 1
    for sum &lt; 1000 {
        sum += sum
    }
    fmt.Println(sum)
}
`</pre></p></li>

<li><p>结果
<pre><code>1024
</code></pre></p></li>

<li><p>無窮迴圈</p></li>

<li><p>如果省略了循環條件，循環就不會結束，因此可以用更簡潔地形式表達無窮迴圈。
<pre>`package main</p>

<p>func main() {
    for {
    }
}
`</pre></p></li>

<li><p>结果
<pre><code>process took too long
</code></pre></p>

<hr />

<h5 id="4-if">4.if</h5></li>

<li><p>就像 for循环一样，Go 的 if语句也不要求用 ( )将条件括起来，同时， { }还是必须有的
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math&rdquo;
)</p>

<p>func sqrt(x float64) string {
    if x &lt; 0 {
        return sqrt(-x) + &ldquo;i&rdquo;
    }
    return fmt.Sprint(math.Sqrt(x))
}</p>

<p>func main() {
    fmt.Println(sqrt(2), sqrt(-4))
}
`</pre></p></li>

<li><p>结果
<pre><code>1.4142135623730951 2i
</code></pre></p>

<hr />

<h5 id="5-if-的便捷语句">5.if 的便捷语句</h5></li>

<li><p>跟 for一样， if语句可以在条件之前执行一个简单语句。</p></li>

<li><p>由这个语句定义的变量的作用域仅在 if范围之内。</p></li>

<li><p>（在最后的 return语句处使用 v看看。）
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math&rdquo;
)</p>

<p>func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v &lt; lim {
        return v
    }
    return lim
}</p>

<p>func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}
`</pre></p></li>

<li><p>结果
<pre><code>9 20
</code></pre></p>

<hr />

<h5 id="6-if-和-else">6.if 和 else</h5></li>

<li><p>在 if的便捷语句定义的变量同样可以在任何对应的 else块中使用。</p></li>

<li><p>（提示：两个 pow调用都在 main调用 fmt.Println前执行完毕了。）
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math&rdquo;
)</p>

<p>func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v &lt; lim {
        return v
    } else {
        fmt.Printf(&ldquo;%g &gt;= %g\n&rdquo;, v, lim)
    }
    // 这里开始就不能使用 v 了
    return lim
}</p>

<p>func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}
`</pre></p></li>

<li><p>结果
<pre><code>27 &amp;gt;= 20
9 20
</code></pre></p>

<hr />

<h5 id="7-switch">7.switch</h5></li>

<li><p>你可能已经知道 switch语句会长什么样了。</p></li>

<li><p>除非以 fallthrough语句结束，否则分支会自动终止
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;runtime&rdquo;
)</p>

<p>func main() {
    fmt.Print(&ldquo;Go runs on &ldquo;)
    switch os := runtime.GOOS; os {
    case &ldquo;darwin&rdquo;:
        fmt.Println(&ldquo;OS X.&rdquo;)
    case &ldquo;linux&rdquo;:
        fmt.Println(&ldquo;Linux.&rdquo;)
    default:
        // freebsd, openbsd,
        // plan9, windows&hellip;
        fmt.Printf(&ldquo;%s.&rdquo;, os)
    }
}
`</pre></p></li>

<li><p>结果
<pre><code>Go runs on nacl.
</code></pre></p>

<hr />

<h5 id="8-switch-的执行顺序">8.switch 的执行顺序</h5></li>

<li><p>switch 的条件从上到下的执行，当匹配成功的时候停止。
（例如，
switch i {case 0:case f():}
当 i==0
时不会调用 f
。）</p></li>

<li><p>注意：Go playground 中的时间总是从 2009-11-10 23:00:00 UTC 开始， 如何校验这个值作为一个练习留给读者完成。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;time&rdquo;
)</p>

<p>func main() {
    fmt.Println(&ldquo;When&rsquo;s Saturday?&rdquo;)
    today := time.Now().Weekday()
    switch time.Saturday {
    case today + 0:
        fmt.Println(&ldquo;Today.&rdquo;)
    case today + 1:
        fmt.Println(&ldquo;Tomorrow.&rdquo;)
    case today + 2:
        fmt.Println(&ldquo;In two days.&rdquo;)
    default:
        fmt.Println(&ldquo;Too far away.&rdquo;)
    }
}
`</pre></p></li>

<li><p>结果
<pre><code>When's Saturday?
Too far away.
</code></pre></p>

<hr />

<h5 id="9-没有条件的-switch">9.没有条件的 switch</h5></li>

<li><p>没有条件的 switch 同 switch true一样。</p></li>

<li><p>这一构造使得可以用更清晰的形式来编写长的 if-then-else 链。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;time&rdquo;
)</p>

<p>func main() {
    t := time.Now()
    switch {
    case t.Hour() &lt; 12:
        fmt.Println(&ldquo;Good morning!&rdquo;)
    case t.Hour() &lt; 17:
        fmt.Println(&ldquo;Good afternoon.&rdquo;)
    default:
        fmt.Println(&ldquo;Good evening.&rdquo;)
    }
}
`</pre></p></li>

<li><p>结果
<pre><code>Good evening.
</code></pre></p>

<hr />

<h5 id="10-defer">10.defer</h5></li>

<li><p>defer 语句会延迟函数的执行直到上层函数返回。</p></li>

<li><p>延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    defer fmt.Println(&ldquo;world&rdquo;)</p>

<pre><code>fmt.Println(&quot;hello&quot;)
</code></pre>

<p>}
`</pre></p></li>

<li><p>结果
<pre><code>hello
world
</code></pre></p>

<hr />

<h5 id="11-defer-栈">11.defer 栈</h5></li>

<li><p>延迟的函数调用被压入一个栈中。当函数返回时， 会按照后进先出的顺序调用被延迟的函数调用。</p></li>

<li><p>阅读<a href="https://link.jianshu.com?t=http://blog.go-zh.org/defer-panic-and-recover">博文</a>了解更多关于 defer
语句的信息。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    fmt.Println(&ldquo;counting&rdquo;)</p>

<pre><code>for i := 0; i &amp;lt; 10; i++ {
    defer fmt.Println(i)
}

fmt.Println(&quot;done&quot;)
</code></pre>

<p>}
`</pre></p></li>

<li><p>结果
<pre><code>counting
done
9
8
7
6
5
4
3
2
1
0
</code></pre></p>

<hr />

<hr />

<hr />

<h5 id="复杂类型-struct-slice-和-map-https-link-jianshu-com-t-https-tour-go-zh-org-moretypes"><a href="https://link.jianshu.com?t=https://tour.go-zh.org/moretypes">复杂类型： struct、slice 和 map。</a></h5></li>

<li><p>学习如何基于已有类型定义新的类型：本课涵盖了结构体、数组、slice 和 map。</p>

<h5 id="1-指针">1.指针</h5></li>

<li><p>Go 具有指针。 指针保存了变量的内存地址。</p></li>

<li><p>类型 <code>*T</code>是指向类型 T的值的指针。其零值是 nil。</p></li>

<li><p><code>var p *int</code></p></li>

<li><p><code>&amp;amp;</code>符号会生成一个指向其作用对象的指针。</p></li>

<li><p><code>i := 42</code></p></li>

<li><p><code>p = &amp;amp;i</code></p></li>

<li><p><code>*</code>符号表示指针指向的底层的值。</p></li>

<li><p><code>fmt.Println(*p) // 通过指针 p 读取 i</code></p></li>

<li><p><code>*p = 21 // 通过指针 p 设置 i</code></p></li>

<li><p>这也就是通常所说的“间接引用”或“非直接引用”。</p></li>

<li><p>与 C 不同，Go 没有指针运算。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    i, j := 42, 2701</p>

<pre><code>p := &amp;amp;i         // point to i
fmt.Println(*p) // read i through the pointer
*p = 21         // set i through the pointer
fmt.Println(i)  // see the new value of i

p = &amp;amp;j         // point to j
*p = *p / 37   // divide j through the pointer
fmt.Println(j) // see the new value of j
</code></pre>

<p>}</p>

<p>`</pre></p></li>

<li><p>结果
<pre><code>42
21
73
</code></pre></p>

<hr />

<h5 id="2-结构体">2.结构体</h5></li>

<li><p>一个结构体（ struct）就是一个字段的集合。</p></li>

<li><p>（而 type的含义跟其字面意思相符。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type Vertex struct {
    X int
    Y int
}</p>

<p>func main() {
    fmt.Println(Vertex{1, 2})
}
`</pre></p></li>

<li><p>结果
<pre><code>{1 2}
</code></pre></p>

<hr />

<h5 id="3-结构体字段">3.结构体字段</h5></li>

<li><p>结构体字段使用点号来访问。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type Vertex struct {
    X int
    Y int
}</p>

<p>func main() {
    v := Vertex{1, 2}
    v.X = 4
    fmt.Println(v.X)
}
`</pre></p></li>

<li><p>结果
<pre><code>4
</code></pre></p>

<hr />

<h5 id="4-结构体指针">4.结构体指针</h5></li>

<li><p>结构体字段可以通过结构体指针来访问。</p></li>

<li><p>通过指针间接的访问是透明的。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type Vertex struct {
    X int
    Y int
}</p>

<p>func main() {
    v := Vertex{1, 2}
    p := &amp;v
    p.X = 1e9
    fmt.Println(v)
}
`</pre></p></li>

<li><p>结果
<pre><code>{1000000000 2}
</code></pre></p>

<hr />

<h5 id="5-结构体文法">5.结构体文法</h5></li>

<li><p>结构体文法表示通过结构体字段的值作为列表来新分配一个结构体。</p></li>

<li><p>使用 Name:语法可以仅列出部分字段。（字段名的顺序无关。）</p></li>

<li><p>特殊的前缀 <code>&amp;amp;</code>返回一个指向结构体的指针。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type Vertex struct {
    X, Y int
}</p>

<p>var (
    v1 = Vertex{1, 2}  // 类型为 Vertex
    v2 = Vertex{X: 1}  // Y:0 被省略
    v3 = Vertex{}      // X:0 和 Y:0
    p  = &amp;Vertex{1, 2} // 类型为 *Vertex
)</p>

<p>func main() {
    fmt.Println(v1, p, v2, v3)
}
`</pre></p></li>

<li><p>结果
<pre><code>{1 2} &amp;amp;{1 2} {1 0} {0 0}
</code></pre></p>

<hr />

<h5 id="6-数组">6.数组</h5></li>

<li><p>类型 [n]T是一个有 n个类型为 T的值的数组。</p></li>

<li><p>表达式</p></li>

<li><p><code>var a [10]int</code></p></li>

<li><p>定义变量 a是一个有十个整数的数组。</p></li>

<li><p>数组的长度是其类型的一部分，因此数组不能改变大小。 这看起来是一个制约，但是请不要担心； Go 提供了更加便利的方式来使用数组。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    var a [2]string
    a[0] = &ldquo;Hello&rdquo;
    a[1] = &ldquo;World&rdquo;
    fmt.Println(a[0], a[1])
    fmt.Println(a)
}
`</pre></p></li>

<li><p>结果
<pre><code>Hello World
[Hello World]
</code></pre></p>

<hr />

<h5 id="7-slice">7.slice</h5></li>

<li><p>一个 slice 会指向一个序列的值，并且包含了长度信息。</p></li>

<li><p><code>[]T</code>是一个元素类型为 T的 slice。</p></li>

<li><p><code>len(s)</code>返回 slice s 的长度。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    s := []int{2, 3, 5, 7, 11, 13}
    fmt.Println(&ldquo;s ==&rdquo;, s)</p>

<pre><code>for i := 0; i &amp;lt; len(s); i++ {
    fmt.Printf(&quot;s[%d] == %d\n&quot;, i, s[i])
}
</code></pre>

<p>}
`</pre></p></li>

<li><p>结果
<pre><code>s == [2 3 5 7 11 13]
s[0] == 2
s[1] == 3
s[2] == 5
s[3] == 7
s[4] == 11
s[5] == 13
</code></pre></p>

<hr />

<h5 id="8-slice-的-slice">8.slice 的 slice</h5></li>

<li><p>slice 可以包含任意的类型，包括另一个 slice。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;strings&rdquo;
)</p>

<p>func main() {
    // Create a tic-tac-toe board.
    game := [][]string{
        []string{&rdquo;<em>&rdquo;, &ldquo;</em>&rdquo;, &ldquo;<em>&rdquo;},
        []string{&rdquo;</em>&rdquo;, &ldquo;<em>&rdquo;, &ldquo;</em>&rdquo;},
        []string{&rdquo;<em>&rdquo;, &ldquo;</em>&rdquo;, &ldquo;_&ldquo;},
    }</p>

<pre><code>// The players take turns.
game[0][0] = &quot;X&quot;
game[2][2] = &quot;O&quot;
game[2][0] = &quot;X&quot;
game[1][0] = &quot;O&quot;
game[0][2] = &quot;X&quot;

printBoard(game)
</code></pre>

<p>}</p>

<p>func printBoard(s [][]string) {
    for i := 0; i &lt; len(s); i++ {
        fmt.Printf(&ldquo;%s\n&rdquo;, strings.Join(s[i], &ldquo; &ldquo;))
    }
}
`</pre></p></li>

<li><p>结果
<pre><code>X _ X
O _ _
X _ O
</code></pre></p>

<hr />

<h5 id="9-对-slice-切片">9.对 slice 切片</h5></li>

<li><p>slice 可以重新切片，创建一个新的 slice 值指向相同的数组。</p></li>

<li><p>表达式</p></li>

<li><p><code>s[lo:hi]</code></p></li>

<li><p>表示从 lo到 hi-1的 slice 元素，含前端，不包含后端。因此</p></li>

<li><p><code>s[lo:lo]</code></p></li>

<li><p>是空的，而</p></li>

<li><p><code>s[lo:lo+1]</code></p></li>

<li><p>有一个元素。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    s := []int{2, 3, 5, 7, 11, 13}
    fmt.Println(&ldquo;s ==&rdquo;, s)
    fmt.Println(&ldquo;s[1:4] ==&ldquo;, s[1:4])</p>

<pre><code>// 省略下标代表从 0 开始
fmt.Println(&quot;s[:3] ==&quot;, s[:3])

// 省略上标代表到 len(s) 结束
fmt.Println(&quot;s[4:] ==&quot;, s[4:])
</code></pre>

<p>}
`</pre></p></li>

<li><p>结果
<pre><code>s == [2 3 5 7 11 13]
s[1:4] == [3 5 7]
s[:3] == [2 3 5]
s[4:] == [11 13]
</code></pre></p>

<hr />

<h5 id="10-构造-slice">10.构造 slice</h5></li>

<li><p>slice 由函数<code>make</code>创建。这会分配一个全是零值的数组并且返回一个 slice 指向这个数组：</p></li>

<li><p><code>a := make([]int, 5) // len(a)=5</code></p></li>

<li><p>为了指定容量，可传递第三个参数到 make：
<pre><code>b := make([]int, 0, 5) // len(b)=0, cap(b)=5
    b = b[:cap(b)] // len(b)=5, cap(b)=5
    b = b[1:] // len(b)=4, cap(b)=4
</code></pre>
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    a := make([]int, 5)
    printSlice(&ldquo;a&rdquo;, a)
    b := make([]int, 0, 5)
    printSlice(&ldquo;b&rdquo;, b)
    c := b[:2]
    printSlice(&ldquo;c&rdquo;, c)
    d := c[2:5]
    printSlice(&ldquo;d&rdquo;, d)
}</p>

<p>func printSlice(s string, x []int) {
    fmt.Printf(&ldquo;%s len=%d cap=%d %v\n&rdquo;,
        s, len(x), cap(x), x)
}
`</pre></p></li>

<li><p>结果
<pre><code>a len=5 cap=5 [0 0 0 0 0]
b len=0 cap=5 []
c len=2 cap=5 [0 0]
d len=3 cap=3 [0 0 0]
</code></pre></p>

<hr />

<h5 id="11-nil-slice">11.nil slice</h5></li>

<li><p>slice 的零值是 nil 。</p></li>

<li><p>一个 nil 的 slice 的长度和容量是 0。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    var z []int
    fmt.Println(z, len(z), cap(z))
    if z == nil {
        fmt.Println(&ldquo;nil!&rdquo;)
    }
}
`</pre></p></li>

<li><p>结果
<pre><code>[] 0 0
nil!
</code></pre></p>

<hr />

<h5 id="12-向-slice-添加元素">12.向 slice 添加元素</h5></li>

<li><p>向 slice 的末尾添加元素是一种常见的操作，因此 Go 提供了一个内建函数 <code>append</code>。 内建函数的<a href="https://link.jianshu.com?t=https://go-zh.org/pkg/builtin/#append">文档</a>对 <code>append</code>有详细介绍。</p></li>

<li><p><code>func append(s []T, vs ...T) []T</code></p></li>

<li><p><code>append</code>的第一个参数 s是一个元素类型为 T的 slice ，其余类型为 T的值将会附加到该 slice 的末尾。</p></li>

<li><p><code>append</code>的结果是一个包含原 slice 所有元素加上新添加的元素的 slice。</p></li>

<li><p>如果 <code>s</code>的底层数组太小，而不能容纳所有值时，会分配一个更大的数组。 返回的 slice 会指向这个新分配的数组。</p></li>

<li><p>（了解更多关于 slice 的内容，参阅文章<a href="https://link.jianshu.com?t=https://blog.go-zh.org/go-slices-usage-and-internals">Go 切片：用法和本质</a>。）
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    var a []int
    printSlice(&ldquo;a&rdquo;, a)</p>

<pre><code>// append works on nil slices.
a = append(a, 0)
printSlice(&quot;a&quot;, a)

// the slice grows as needed.
a = append(a, 1)
printSlice(&quot;a&quot;, a)

// we can add more than one element at a time.
a = append(a, 2, 3, 4)
printSlice(&quot;a&quot;, a)
</code></pre>

<p>}</p>

<p>func printSlice(s string, x []int) {
    fmt.Printf(&ldquo;%s len=%d cap=%d %v\n&rdquo;,
        s, len(x), cap(x), x)
}
`</pre></p></li>

<li><p>结果
<pre><code>a len=0 cap=0 []
a len=1 cap=2 [0]
a len=2 cap=2 [0 1]
a len=5 cap=8 [0 1 2 3 4]
</code></pre></p>

<hr />

<hr />

<hr />

<h5 id="go-切片-用法和本质-https-link-jianshu-com-t-https-blog-go-zh-org-go-slices-usage-and-internals"><a href="https://link.jianshu.com?t=https://blog.go-zh.org/go-slices-usage-and-internals">Go 切片：用法和本质</a></h5>

<p><strong>引言</strong></p></li>

<li><p>Go的切片类型为处理同类型数据序列提供一个方便而高效的方式。 切片有些类似于其他语言中的数组，但是有一些不同寻常的特性。 本文将深入切片的本质，并讲解它的用法。</p>

<p><strong>数组</strong></p></li>

<li><p>Go的切片是在数组之上的抽象数据类型，因此在了解切片之前必须要先理解数组。</p></li>

<li><p>数组类型定义了长度和元素类型。例如， [4]int 类型表示一个四个整数的数组。 数组的长度是固定的，长度是数组类型的一部分（ [4]int和 [5]int
是完全不同的类型）。 数组可以以常规的索引方式访问，表达式 s[n]
访问数组的第 n 个元素。
<pre><code>var a [4]int
a[0] = 1
i := a[0]
// i == 1
</code></pre></p></li>

<li><p>数组不需要显式的初始化；数组的零值是可以直接使用的，数组元素会自动初始化为其对应类型的零值：</p></li>

<li><p><code>// a[2] == 0, int 类型的零值</code></p></li>

<li><p>类型 [4]int对应内存中四个连续的整数：
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 211px;">
<div class="image-container-fill" style="padding-bottom: 22.71%;"></div>
<div class="image-view" data-width="929" data-height="211"><img src="//upload-images.jianshu.io/upload_images/739863-a13db3f4b948dc6c.png" alt="" /></div>
</div>
<div class="image-caption">类型 [4]int对应内存中四个连续的整数</div>
</div></p></li>

<li><p>Go的数组是值语义。一个数组变量表示整个数组，它不是指向第一个元素的指针（不像 C 语言的数组）。 当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。 （为了避免复制数组，你可以传递一个指向数组的指针，但是数组指针并不是数组。） 可以将数组看作一个特殊的struct，结构的字段名对应数组的索引，同时成员的数目固定。</p></li>

<li><p>数组的字面值像这样：</p></li>

<li><p><code>b := [2]string{&quot;Penn&quot;, &quot;Teller&quot;}</code></p></li>

<li><p>当然，也可以让编译器统计数组字面值中元素的数目：</p></li>

<li><p><code>b := [...]string{&quot;Penn&quot;, &quot;Teller&quot;}</code></p></li>

<li><p>这两种写法， b都是对应 [2]string类型。</p>

<p><strong>切片</strong></p></li>

<li><p>数组虽然有适用它们的地方，但是数组不够灵活，因此在Go代码中数组使用的并不多。 但是，切片则使用得相当广泛。切片基于数组构建，但是提供更强的功能和便利。</p></li>

<li><p>切片类型的写法是 []T， T是切片元素的类型。和数组不同的是，切片类型并没有给定固定的长度。</p></li>

<li><p>切片的字面值和数组字面值很像，不过切片没有指定元素个数：</p></li>

<li><p><code>letters := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}</code></p></li>

<li><p>切片可以使用内置函数 make创建，函数签名为：</p></li>

<li><p><code>func make([]T, len, cap) []T</code></p></li>

<li><p>其中T代表被创建的切片元素的类型。函数 make接受一个类型、一个长度和一个可选的容量参数。 调用 make时，内部会分配一个数组，然后返回数组对应的切片。</p></li>

<li><p><code>var s []bytes = make([]byte, 5, 5)// s == []byte{0, 0, 0, 0, 0}</code></p></li>

<li><p>当容量参数被忽略时，它默认为指定的长度。下面是简洁的写法：</p></li>

<li><p><code>s := make([]byte, 5)</code></p></li>

<li><p>可以使用内置函数 <code>len</code>和<code>cap</code>获取切片的长度和容量信息。
<pre><code>len(s) == 5
  cap(s) == 5
</code></pre></p></li>

<li><p>接下来的两个小节将讨论长度和容量之间的关系。</p></li>

<li><p>切片的零值为<code>nil</code>。对于切片的零值， <code>len</code>和<code>cap</code>都将返回0。</p></li>

<li><p>切片也可以基于现有的切片或数组生成。切分的范围由两个由冒号分割的索引对应的半开区间指定。 例如，表达式<code>b[1:4]</code>创建的切片引用数组 b
的第1到3个元素空间（对应切片的索引为0到2）。
<pre><code>b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
// b[1:4] == []byte{'o', 'l', 'a'}, sharing the same storage as b
</code></pre></p></li>

<li><p>切片的开始和结束的索引都是可选的；它们分别默认为零和数组的长度。
<pre><code>// b[:2] == []byte{'g', 'o'}
// b[2:] == []byte{'l', 'a', 'n', 'g'}
// b[:] == b
</code></pre></p></li>

<li><p>下面语法也是基于数组创建一个切片：
<pre><code>x := [3]string{&quot;Лайка&quot;, &quot;Белка&quot;, &quot;Стрелка&quot;}
s := x[:] // a slice referencing the storage of x
</code></pre></p>

<p><strong>切片的内幕</strong></p></li>

<li><p>一个切片是一个数组片段的描述。它包含了指向数组的指针，片段的长度， 和容量（片段的最大长度）。
<div class="image-package">
<div class="image-container" style="max-width: 659px; max-height: 478px;">
<div class="image-container-fill" style="padding-bottom: 72.53%;"></div>
<div class="image-view" data-width="659" data-height="478"><img src="//upload-images.jianshu.io/upload_images/739863-3ca30a0fcddbd57f.png" alt="" /></div>
</div>
<div class="image-caption">切片是一个数组片段的描述</div>
</div></p></li>

<li><p>前面使用 make([]byte, 5)创建的切片变量 s的结构如下：
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 480px;">
<div class="image-container-fill" style="padding-bottom: 31.77%;"></div>
<div class="image-view" data-width="1511" data-height="480"><img src="//upload-images.jianshu.io/upload_images/739863-3587c5ce5d53803d.png" alt="" /></div>
</div>
<div class="image-caption">s的结构</div>
</div></p></li>

<li><p>长度是切片引用的元素数目。容量是底层数组的元素数目（从切片指针开始）。 关于长度和容量和区域将在下一个例子说明。</p></li>

<li><p>我们继续对 s进行切片，观察切片的数据结构和它引用的底层数组：</p></li>

<li><p><code>s = s[2:4]</code>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 330px;">
<div class="image-container-fill" style="padding-bottom: 25.679999999999996%;"></div>
<div class="image-view" data-width="1285" data-height="330"><img src="//upload-images.jianshu.io/upload_images/739863-2360c543a8bad525.png" alt="" /></div>
</div>
<div class="image-caption">数据结构和它引用的底层数组</div>
</div></p></li>

<li><p>切片操作并不复制切片指向的元素。它创建一个新的切片并复用原来切片的底层数组。 这使得切片操作和数组索引一样高效。因此，通过一个新切片修改元素会影响到原始切片的对应元素。
<pre><code>d := []byte{'r', 'o', 'a', 'd'}
e := d[2:] 
// e == []byte{'a', 'd'}
e[1] = 'm'
// e == []byte{'a', 'm'}
// d == []byte{'r', 'o', 'a', 'm'}
</code></pre></p></li>

<li><p>前面创建的切片 s长度小于它的容量。我们可以增长切片的长度为它的容量：</p></li>

<li><p><code>s = s[:cap(s)]</code>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 363px;">
<div class="image-container-fill" style="padding-bottom: 28.67%;"></div>
<div class="image-view" data-width="1266" data-height="363"><img src="//upload-images.jianshu.io/upload_images/739863-0e860e5ad7b65ee3.png" alt="" /></div>
</div>
<div class="image-caption"></div>
</div></p></li>

<li><p>切片增长不能超出其容量。增长超出切片容量将会导致运行时异常，就像切片或数组的索引超 出范围引起异常一样。同样，不能使用小于零的索引去访问切片之前的元素。</p>

<p><strong>切片的生长（copy and append 函数）</strong></p></li>

<li><p>要增加切片的容量必须创建一个新的、更大容量的切片，然后将原有切片的内容复制到新的切片。 整个技术是一些支持动态数组语言的常见实现。下面的例子将切片 s容量翻倍，先创建一个2倍 容量的新切片 t，复制 s的元素到 t，然后将 t赋值给 s：
<pre><code>t := make([]byte, len(s), (cap(s)+1)*2) // +1 in case cap(s) == 0
for i := range s { 
          t[i] = s[i]
}
s = t
</code></pre></p></li>

<li><p>循环中复制的操作可以由 copy 内置函数替代。copy 函数将源切片的元素复制到目的切片。 它返回复制元素的数目。</p></li>

<li><p><code>func copy(dst, src []T) int</code></p></li>

<li><p><code>copy</code>函数支持不同长度的切片之间的复制（它只复制较短切片的长度个元素）。 此外,<code>copy</code>函数可以正确处理源和目的切片有重叠的情况。</p></li>

<li><p>使用 copy函数，我们可以简化上面的代码片段：
<pre><code>t := make([]byte, len(s), (cap(s)+1)*2)
copy(t, s)
s = t
</code></pre></p></li>

<li><p>一个常见的操作是将数据追加到切片的尾部。下面的函数将元素追加到切片尾部， 必要的话会增加切片的容量，最后返回更新的切片：
<pre><code>func AppendByte(slice []byte, data ...byte) []byte { 
    m := len(slice) 
    n := m + len(data) 
    if n &amp;gt; cap(slice) { // if necessary, reallocate 
        // allocate double what's needed, for future growth. 
        newSlice := make([]byte, (n+1)*2) 
        copy(newSlice, slice) slice = newSlice 
    } 
    slice = slice[0:n] 
    copy(slice[m:n], data) 
    return slice
}
</code></pre></p></li>

<li><p>下面是 AppendByte的一种用法：
<pre><code>p := []byte{2, 3, 5}
p = AppendByte(p, 7, 11, 13)
// p == []byte{2, 3, 5, 7, 11, 13}
</code></pre></p></li>

<li><p>类似 AppendByte的函数比较实用，因为它提供了切片容量增长的完全控制。 根据程序的特点，可能希望分配较小的活较大的块，或则是超过某个大小再分配。</p></li>

<li><p>但大多数程序不需要完全的控制，因此Go提供了一个内置函数 append， 用于大多数场合；它的函数签名：</p></li>

<li><p><code>func append(s []T, x ...T) []T</code></p></li>

<li><p>append函数将 x追加到切片 s的末尾，并且在必要的时候增加容量。
<pre><code>a := make([]int, 1)
// a == []int{0}
a = append(a, 1, 2, 3)
// a == []int{0, 1, 2, 3}
</code></pre></p></li>

<li><p>如果是要将一个切片追加到另一个切片尾部，需要使用 &hellip;语法将第2个参数展开为参数列表。
<pre><code>a := []string{&quot;John&quot;, &quot;Paul&quot;}
b := []string{&quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}
a = append(a, b...) // equivalent to &quot;append(a, b[0], b[1], b[2])&quot;
// a == []string{&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}
</code></pre></p></li>

<li><p>由于切片的零值 nil用起来就像一个长度为零的切片，我们可以声明一个切片变量然后在循环 中向它追加数据：
<pre><code>// Filter returns a new slice holding only
// the elements of s that satisfy f()
func Filter(s []int, fn func(int) bool) []int { 
    var p []int // == nil 
    for _, v := range s { 
        if fn(v) { p = append(p, v) 
            } 
        } 
        return p
}
</code></pre></p>

<p><strong>可能的“陷阱”</strong></p></li>

<li><p>正如前面所说，切片操作并不会复制底层的数组。整个数组将被保存在内存中，直到它不再被引用。 有时候可能会因为一个小的内存引用导致保存所有的数据。</p></li>

<li><p>例如， <code>FindDigits</code>函数加载整个文件到内存，然后搜索第一个连续的数字，最后结果以切片方式返回。
<pre><code>var digitRegexp = regexp.MustCompile(&quot;[0-9]+&quot;)
func FindDigits(filename string) []byte { 
    b, _ := ioutil.ReadFile(filename) 
    return digitRegexp.Find(b)
}
</code></pre></p></li>

<li><p>这段代码的行为和描述类似，返回的<code>[]byte</code>指向保存整个文件的数组。因为切片引用了原始的数组， 导致 GC 不能释放数组的空间；只用到少数几个字节却导致整个文件的内容都一直保存在内存里。</p></li>

<li><p>要修复整个问题，可以将感兴趣的数据复制到一个新的切片中：
<pre><code>func CopyDigits(filename string) []byte { 
    b, _ := ioutil.ReadFile(filename) 
    b = digitRegexp.Find(b) 
    c := make([]byte, len(b)) 
    copy(c, b) return c
}
</code></pre></p></li>

<li><p>可以使用 append实现一个更简洁的版本。这留给读者作为练习。</p>

<p><strong>延伸阅读</strong></p></li>

<li><p><a href="https://link.jianshu.com?t=https://go-zh.org/doc/effective_go.html">实效 Go 编程</a> 包含了对 <a href="https://link.jianshu.com?t=https://go-zh.org/doc/effective_go.html#%E5%88%87%E7%89%87">切片</a>和 <a href="https://link.jianshu.com?t=https://go-zh.org/doc/effective_go.html#%E6%95%B0%E7%BB%84">数组</a>更深入的探讨； <a href="https://link.jianshu.com?t=https://go-zh.org/ref/spec">Go 编程语言规范</a>对 <a href="https://link.jianshu.com?t=https://go-zh.org/ref/spec#Slice_types">切片类型</a>和 <a href="https://link.jianshu.com?t=https://go-zh.org/ref/spec#Array_types">数组类型</a> 以及操作他们的内建函数（<a href="https://link.jianshu.com?t=https://go-zh.org/ref/spec#Length_and_capacity">len/cap</a>， <a href="https://link.jianshu.com?t=https://go-zh.org/ref/spec#Making_slices_maps_and_channels">make</a>和 <a href="https://link.jianshu.com?t=https://go-zh.org/ref/spec#Appending_and_copying_slices">copy/append</a>） 进行了定义。</p></li>

<li><p>本文由 <a href="https://link.jianshu.com?t=https://go-zh.org/">Go-zh 项目组</a> 翻译，转载请注明出处。</p>

<hr />

<h5 id="13-range">13.range</h5></li>

<li><p>for循环的 range格式可以对 slice 或者 map 进行迭代循环。</p></li>

<li><p>当使用 for循环遍历一个 slice 时，每次迭代 range将返回两个值。 第一个是当前下标（序号），第二个是该下标所对应元素的一个拷贝。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}</p>

<p>func main() {
    for i, v := range pow {
        fmt.Printf(&ldquo;2**%d = %d\n&rdquo;, i, v)
    }
}
`</pre></p></li>

<li><p>结果
<pre><code>2**0 = 1
2**1 = 2
2**2 = 4
2**3 = 8
2**4 = 16
2**5 = 32
2**6 = 64
2**7 = 128
</code></pre></p>

<hr />

<h5 id="14-range-续">14.range（续）</h5></li>

<li><p>可以通过赋值给 _来忽略序号和值。</p></li>

<li><p>如果只需要索引值，去掉 “ , value ” 的部分即可。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    pow := make([]int, 10)
    for i := range pow {
        pow[i] = 1 &lt;&lt; uint(i)
    }
    for _, value := range pow {
        fmt.Printf(&ldquo;%d\n&rdquo;, value)
    }
}
`</pre></p></li>

<li><p>结果
<pre><code>1
2
4
8
16
32
64
128
256
512
</code></pre></p>

<hr />

<h5 id="15-map">15.map</h5></li>

<li><p>map 映射键到值。</p></li>

<li><p>map 在使用之前必须用 make来创建；值为 nil的 map 是空的，并且不能对其赋值。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type Vertex struct {
    Lat, Long float64
}</p>

<p>var m map[string]Vertex</p>

<p>func main() {
    m = make(map[string]Vertex)
    m[&ldquo;Bell Labs&rdquo;] = Vertex{
        40.68433, -74.39967,
    }
    fmt.Println(m[&ldquo;Bell Labs&rdquo;])
}
`</pre></p></li>

<li><p>结果
<pre><code>{40.68433 -74.39967}
</code></pre></p>

<hr />

<h5 id="16-map-的文法">16.map 的文法</h5></li>

<li><p>map 的文法跟结构体文法相似，不过必须有键名
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type Vertex struct {
    Lat, Long float64
}</p>

<p>var m = map[string]Vertex{
    &ldquo;Bell Labs&rdquo;: Vertex{
        40.68433, -74.39967,
    },
    &ldquo;Google&rdquo;: Vertex{
        37.42202, -122.08408,
    },
}</p>

<p>func main() {
    fmt.Println(m)
}
`</pre></p></li>

<li><p>结果
<pre><code>map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]
</code></pre></p>

<hr />

<h5 id="17-map-的文法-续">17.map 的文法（续）</h5></li>

<li><p>若顶级类型只是一个类型名，你可以在文法的元素中省略它。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type Vertex struct {
    Lat, Long float64
}</p>

<p>var m = map[string]Vertex{
    &ldquo;Bell Labs&rdquo;: {40.68433, -74.39967},
    &ldquo;Google&rdquo;:    {37.42202, -122.08408},
}</p>

<p>func main() {
    fmt.Println(m)
}
`</pre></p></li>

<li><p>结果
<pre><code>map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]
</code></pre></p>

<hr />

<h5 id="18-修改-map">18.修改 map</h5></li>

<li><p>在 map m中插入或修改一个元素：</p></li>

<li><p><code>m[key] = elem</code></p></li>

<li><p>获得元素：</p></li>

<li><p><code>elem = m[key]</code></p></li>

<li><p>删除元素：</p></li>

<li><p><code>delete(m, key)</code></p></li>

<li><p>通过双赋值检测某个键存在：</p></li>

<li><p><code>elem, ok = m[key]</code></p></li>

<li><p>如果 key在 m中， ok为 true。否则， ok为 false，并且 elem是 map 的元素类型的零值。</p></li>

<li><p>同样的，当从 map 中读取某个不存在的键时，结果是 map 的元素类型的零值。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    m := make(map[string]int)</p>

<pre><code>m[&quot;Answer&quot;] = 42
fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])

m[&quot;Answer&quot;] = 48
fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])

delete(m, &quot;Answer&quot;)
fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])

v, ok := m[&quot;Answer&quot;]
fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)
</code></pre>

<p>}
`</pre></p></li>

<li><p>结果
<pre><code>The value: 42
The value: 48
The value: 0
The value: 0 Present? false
</code></pre></p>

<hr />

<h5 id="19-函数值">19.函数值</h5></li>

<li><p>函数也是值。他们可以像其他值一样传递，比如，函数值可以作为函数的参数或者返回值。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math&rdquo;
)</p>

<p>func compute(fn func(float64, float64) float64) float64 {
    return fn(3, 4)
}</p>

<p>func main() {
    hypot := func(x, y float64) float64 {
        return math.Sqrt(x*x + y*y)
    }
    fmt.Println(hypot(5, 12))</p>

<pre><code>fmt.Println(compute(hypot))
fmt.Println(compute(math.Pow))
</code></pre>

<p>}
`</pre></p></li>

<li><p>结果
<pre><code>13
5
81
</code></pre></p>

<hr />

<h5 id="20-函数的闭包">20.函数的闭包</h5></li>

<li><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了函数体之外的变量。 这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。</p></li>

<li><p>例如，函数 <code>adder</code>返回一个闭包。每个返回的闭包都被绑定到其各自的<code>sum</code>变量上。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}</p>

<p>func main() {
    pos, neg := adder(), adder()
    for i := 0; i &lt; 10; i++ {
        fmt.Println(
            pos(i),
            neg(-2*i),
        )
    }
}
`</pre></p></li>

<li><p>结果
<pre><code>1 -2
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90
</code></pre></p>

<hr />

<hr />

<hr />

<h5 id="方法和接口-https-link-jianshu-com-t-https-tour-go-zh-org-methods"><a href="https://link.jianshu.com?t=https://tour.go-zh.org/methods">方法和接口</a></h5></li>

<li><p>学习如何为类型定义方法；如何定义接口；可以用它们来定义对象和其行为。</p>

<h5 id="1-方法">1.方法</h5></li>

<li><p>Go 没有类。然而，仍然可以在结构体类型上定义方法。</p></li>

<li><p><em>方法接收者</em> 出现在 func关键字和方法名之间的参数中。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math&rdquo;
)</p>

<p>type Vertex struct {
    X, Y float64
}</p>

<p>func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}</p>

<p>func main() {
    v := &amp;Vertex{3, 4}
    fmt.Println(v.Abs())
}
`</pre></p></li>

<li><p>结果：
<pre><code>5
</code></pre></p>

<hr />

<h5 id="2-方法-续">2.方法（续）</h5></li>

<li><p>你可以对包中的 <em>任意</em> 类型定义任意方法，而不仅仅是针对结构体。</p></li>

<li><p>但是，不能对来自其他包的类型或基础类型定义方法。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math&rdquo;
)</p>

<p>type MyFloat float64</p>

<p>func (f MyFloat) Abs() float64 {
    if f &lt; 0 {
        return float64(-f)
    }
    return float64(f)
}</p>

<p>func main() {
    f := MyFloat(-math.Sqrt2)
    fmt.Println(f.Abs())
}
`</pre></p></li>

<li><p>结果：
<pre><code>1.4142135623730951
</code></pre></p>

<hr />

<h5 id="3-接收者为指针的方法">3.接收者为指针的方法</h5></li>

<li><p>方法可以与命名类型或命名类型的指针关联。</p></li>

<li><p>刚刚看到的两个 Abs方法。一个是在<code>*Vertex</code>指针类型上，而另一个在 <code>MyFloat</code>值类型上。 有两个原因需要使用指针接收者。首先避免在每个方法调用中拷贝值（如果值类型是大的结构体的话会更有效率）。其次，方法可以修改接收者指向的值。</p></li>

<li><p>尝试修改 Abs的定义，同时 <code>Scale</code>方法使用 <code>Vertex</code> 代替<code>*Vertex</code>作为接收者。</p></li>

<li><p>当 v是<code>Vertex</code>的时候<code>Scale</code>方法没有任何作用。<code>Scale</code>修改 v。当 v是一个值（非指针），方法看到的是 Vertex的副本，并且无法修改原始值。</p></li>

<li><p>Abs的工作方式是一样的。只不过，仅仅读取 v。所以读取的是原始值（通过指针）还是那个值的副本并没有关系。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math&rdquo;
)</p>

<p>type Vertex struct {
    X, Y float64
}</p>

<p>func (v *Vertex) Scale(f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}</p>

<p>func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}</p>

<p>func main() {
    v := &amp;Vertex{3, 4}
    fmt.Printf(&ldquo;Before scaling: %+v, Abs: %v\n&rdquo;, v, v.Abs())
    v.Scale(5)
    fmt.Printf(&ldquo;After scaling: %+v, Abs: %v\n&rdquo;, v, v.Abs())
}
`</pre></p></li>

<li><p>结果：
<pre><code>Before scaling: &amp;amp;{X:3 Y:4}, Abs: 5
After scaling: &amp;amp;{X:15 Y:20}, Abs: 25
</code></pre></p>

<hr />

<h5 id="4-接口">4.接口</h5></li>

<li><p>接口类型是由一组方法定义的集合。</p></li>

<li><p>接口类型的值可以存放实现这些方法的任何值。</p></li>

<li><p><strong>注意</strong>： 示例代码的 22 行存在一个错误。 由于 Abs只定义在 <code>*Vertex</code>（指针类型）上， 所以 <code>Vertex</code>（值类型）不满足 Abser。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;math&rdquo;
)</p>

<p>type Abser interface {
    Abs() float64
}</p>

<p>func main() {
    var a Abser
    f := MyFloat(-math.Sqrt2)
    v := Vertex{3, 4}</p>

<pre><code>a = f  // a MyFloat 实现了 Abser
a = &amp;amp;v // a *Vertex 实现了 Abser

// 下面一行，v 是一个 Vertex（而不是 *Vertex）
// 所以没有实现 Abser。
a = v

fmt.Println(a.Abs())
</code></pre>

<p>}</p>

<p>type MyFloat float64</p>

<p>func (f MyFloat) Abs() float64 {
    if f &lt; 0 {
        return float64(-f)
    }
    return float64(f)
}</p>

<p>type Vertex struct {
    X, Y float64
}</p>

<p>func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
`</pre></p></li>

<li><p>结果：
<pre><code>5
</code></pre></p>

<hr />

<h5 id="5-隐式接口">5.隐式接口</h5></li>

<li><p>类型通过实现那些方法来实现接口。 没有显式声明的必要；所以也就没有关键字“implements“。</p></li>

<li><p>隐式接口解藕了实现接口的包和定义接口的包：互不依赖。</p></li>

<li><p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p></li>

<li><p><a href="https://link.jianshu.com?t=https://go-zh.org/pkg/io/">包 io</a> 定义了 Reader
和 Writer；其实不一定要这么做。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;os&rdquo;
)</p>

<p>type Reader interface {
    Read(b []byte) (n int, err error)
}</p>

<p>type Writer interface {
    Write(b []byte) (n int, err error)
}</p>

<p>type ReadWriter interface {
    Reader
    Writer
}</p>

<p>func main() {
    var w Writer</p>

<pre><code>// os.Stdout 实现了 Writer
w = os.Stdout

fmt.Fprintf(w, &quot;hello, writer\n&quot;)
</code></pre>

<p>}
`</pre></p></li>

<li><p>结果：
<pre><code>hello, writer
</code></pre></p>

<hr />

<h5 id="6-stringers">6.Stringers</h5></li>

<li><p>一个普遍存在的接口是 <a href="https://link.jianshu.com?t=https://go-zh.org/pkg/fmt/">fmt
</a> 包中定义的 <a href="https://link.jianshu.com?t=https://go-zh.org/pkg/fmt/#Stringer">Stringer
</a>。
<pre><code>type Stringer interface { 
    String() string
}
</code></pre></p></li>

<li><p>Stringer是一个可以用字符串描述自己的类型。<code>fmt</code>包 （还有许多其他包）使用这个来进行输出。
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>type Person struct {
    Name string
    Age  int
}</p>

<p>func (p Person) String() string {
    return fmt.Sprintf(&ldquo;%v (%v years)&rdquo;, p.Name, p.Age)
}</p>

<p>func main() {
    a := Person{&ldquo;Arthur Dent&rdquo;, 42}
    z := Person{&ldquo;Zaphod Beeblebrox&rdquo;, 9001}
    fmt.Println(a, z)
}
`</pre></p></li>

<li><p>结果：
<pre><code>Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)
</code></pre></p>

<hr />

<h5 id="7-错误">7.错误</h5></li>

<li><p>Go 程序使用 error值来表示错误状态。</p></li>

<li><p>与 fmt.Stringer类似， error类型是一个内建接口：
<pre><code>type error interface { 
    Error() string
}
</code></pre></p></li>

<li><p>（与 fmt.Stringer类似，fmt包在输出时也会试图匹配 error。）</p></li>

<li><p>通常函数会返回一个 error值，调用的它的代码应当判断这个错误是否等于 nil， 来进行错误处理。
<pre><code>i, err := strconv.Atoi(&quot;42&quot;)
if err != nil { 
    fmt.Printf(&quot;couldn't convert number: %v\n&quot;, err)
    return}
fmt.Println(&quot;Converted integer:&quot;, i)
</code></pre></p></li>

<li><p>error 为 nil 时表示成功；非 nil 的 error表示错误。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;time&rdquo;
)</p>

<p>type MyError struct {
    When time.Time
    What string
}</p>

<p>func (e *MyError) Error() string {
    return fmt.Sprintf(&ldquo;at %v, %s&rdquo;,
        e.When, e.What)
}</p>

<p>func run() error {
    return &amp;MyError{
        time.Now(),
        &ldquo;it didn&rsquo;t work&rdquo;,
    }
}</p>

<p>func main() {
    if err := run(); err != nil {
        fmt.Println(err)
    }
}
`</pre></p></li>

<li><p>结果：
<pre><code>at 2009-11-10 23:00:00 +0000 UTC, it didn't work
</code></pre></p>

<hr />

<h5 id="8-readers">8.Readers</h5></li>

<li><p>io包指定了 io.Reader接口， 它表示从数据流结尾读取。</p></li>

<li><p>Go 标准库包含了这个接口的<a href="https://link.jianshu.com?t=https://go-zh.org/search?q=Read#Global">许多实现</a>， 包括文件、网络连接、压缩、加密等等。</p></li>

<li><p>io.Reader接口有一个 Read方法：
<pre><code>func (T) Read(b []byte) (n int, err error)
</code></pre></p></li>

<li><p>Read用数据填充指定的字节 slice，并且返回填充的字节数和错误信息。 在遇到数据流结尾时，返回 io.EOF错误。</p></li>

<li><p>例子代码创建了一个 <a href="https://link.jianshu.com?t=https://go-zh.org/pkg/strings/#Reader">strings.Reader</a>。 并且以每次 8 字节的速度读取它的输出。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;io&rdquo;
    &ldquo;strings&rdquo;
)</p>

<p>func main() {
    r := strings.NewReader(&ldquo;Hello, Reader!&rdquo;)</p>

<pre><code>b := make([]byte, 8)
for {
    n, err := r.Read(b)
    fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b)
    fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n])
    if err == io.EOF {
        break
    }
}
</code></pre>

<p>}
`</pre></p></li>

<li><p>结果：
<pre><code>n = 8 err = &amp;lt;nil&amp;gt; b = [72 101 108 108 111 44 32 82]
b[:n] = &quot;Hello, R&quot;
n = 6 err = &amp;lt;nil&amp;gt; b = [101 97 100 101 114 33 32 82]
b[:n] = &quot;eader!&quot;
n = 0 err = EOF b = [101 97 100 101 114 33 32 82]
b[:n] = &quot;&quot;
</code></pre></p>

<hr />

<h5 id="9-web-服务器">9.Web 服务器</h5></li>

<li><p><a href="https://link.jianshu.com?t=https://go-zh.org/pkg/net/http/">包 http</a> 通过任何实现了 http.Handler
的值来响应 HTTP 请求：
<pre>`package http</p>

<p>type Handler interface {
    ServeHTTP(w ResponseWriter, r *Request)
}
`</pre></p></li>

<li><p>在这个例子中，类型 Hello实现了 http.Handler。</p></li>

<li><p>访问 <a href="https://link.jianshu.com?t=http://localhost:4000/">http://localhost:4000/</a> 会看到来自程序的问候。</p></li>

<li><p><em>注意：</em> 这个例子无法在基于 web 的指南用户界面运行。为了尝试编写 web 服务器，可能需要<a href="https://link.jianshu.com?t=https://go-zh.org/doc/install/">安装 Go</a>。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;log&rdquo;
    &ldquo;net/http&rdquo;
)</p>

<p>type Hello struct{}</p>

<p>func (h Hello) ServeHTTP(
    w http.ResponseWriter,
    r *http.Request) {
    fmt.Fprint(w, &ldquo;Hello!&rdquo;)
}</p>

<p>func main() {
    var h Hello
    err := http.ListenAndServe(&ldquo;localhost:4000&rdquo;, h)
    if err != nil {
        log.Fatal(err)
    }
}
`</pre></p></li>

<li><p>结果：
<pre><code>2009/11/10 23:00:00 listen tcp: Protocol not available
</code></pre></p>

<hr />

<h5 id="10-图片">10.图片</h5></li>

<li><p><a href="https://link.jianshu.com?t=https://go-zh.org/pkg/image/#Image">Package image</a> 定义了 Image
接口：
<pre>`package image</p>

<p>type Image interface {
    ColorModel() color.Model
    Bounds() Rectangle
    At(x, y int) color.Color
}
`</pre></p></li>

<li><p><strong>注意</strong>：Bounds方法的 Rectangle返回值实际上是一个 <a href="https://link.jianshu.com?t=https://go-zh.org/pkg/image/#Rectangle">image.Rectangle</a>， 其定义在 image包中。</p></li>

<li><p>（参阅<a href="https://link.jianshu.com?t=https://go-zh.org/pkg/image/#Image">文档</a>了解全部信息。）</p></li>

<li><p>color.Color和 color.Model也是接口，但是通常因为直接使用预定义的实现 image.RGBA和 image.RGBAModel而被忽视了。这些接口和类型由<a href="https://link.jianshu.com?t=https://go-zh.org/pkg/image/color/">image/color包</a>定义。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;image&rdquo;
)</p>

<p>func main() {
    m := image.NewRGBA(image.Rect(0, 0, 100, 100))
    fmt.Println(m.Bounds())
    fmt.Println(m.At(0, 0).RGBA())
}
`</pre></p></li>

<li><p>结果：
<pre><code>(0,0)-(100,100)
0 0 0 0
</code></pre></p>

<hr />

<hr />

<hr />

<h5 id="并发-https-link-jianshu-com-t-https-tour-go-zh-org-concurrency"><a href="https://link.jianshu.com?t=https://tour.go-zh.org/concurrency">并发</a></h5></li>

<li><p>作为语言的核心部分，Go 提供了并发的特性。</p></li>

<li><p>这一部分概览了 goroutine 和 channel，以及如何使用它们来实现不同的并发模式。</p></li>

<li><p>Go 将并发作为语言的核心构成。</p>

<h5 id="1-goroutine">1.goroutine</h5></li>

<li><p><em>goroutine</em> 是由 Go 运行时环境管理的轻量级线程。</p></li>

<li><p><code>go f(x, y, z)</code></p></li>

<li><p>开启一个新的 goroutine 执行</p></li>

<li><p><code>f(x, y, z)</code></p></li>

<li><p>f，x，y和 z是当前 goroutine 中定义的，但是在新的 goroutine 中运行 f。</p></li>

<li><p>goroutine 在相同的地址空间中运行，因此访问共享内存必须进行同步。<a href="https://link.jianshu.com?t=https://go-zh.org/pkg/sync/">sync</a> 提供了这种可能，不过在 Go 中并不经常用到，因为有其他的办法。（在接下来的内容中会涉及到。）
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;time&rdquo;
)</p>

<p>func say(s string) {
    for i := 0; i &lt; 5; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
}</p>

<p>func main() {
    go say(&ldquo;world&rdquo;)
    say(&ldquo;hello&rdquo;)
}
`</pre></p></li>

<li><p>结果：
<pre><code>hello
hello
world
world
hello
hello
world
world
hello
</code></pre></p>

<hr />

<h5 id="2-channel">2.channel</h5></li>

<li><p>channel 是有类型的管道，可以用 channel 操作符 &lt;-对其发送或者接收值。
<pre><code>ch &amp;lt;- v // 将 v 送入 channel ch。
v := &amp;lt;-ch // 从 ch 接收，并且赋值给 v。
</code></pre></p></li>

<li><p>（“箭头”就是数据流的方向。）</p></li>

<li><p>和 map 与 slice 一样，channel 使用前必须创建：</p></li>

<li><p><code>ch := make(chan int)</code></p></li>

<li><p>默认情况下，在另一端准备好之前，发送和接收都会阻塞。这使得 goroutine 可以在没有明确的锁或竞态变量的情况下进行同步
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func sum(a []int, c chan int) {
    sum := 0
    for _, v := range a {
        sum += v
    }
    c &lt;- sum // 将和送入 c
}</p>

<p>func main() {
    a := []int{7, 2, 8, -9, 4, 0}</p>

<pre><code>c := make(chan int)
go sum(a[:len(a)/2], c)
go sum(a[len(a)/2:], c)
x, y := &amp;lt;-c, &amp;lt;-c // 从 c 中获取

fmt.Println(x, y, x+y)
</code></pre>

<p>}
`</pre></p></li>

<li><p>结果：
<pre><code>-5 17 12
</code></pre></p>

<hr />

<h5 id="3-缓冲-channel">3.缓冲 channel</h5></li>

<li><p>channel 可以是 _带缓冲的_。为 make提供第二个参数作为缓冲长度来初始化一个缓冲 channel：</p></li>

<li><p><code>ch := make(chan int, 100)</code></p></li>

<li><p>向带缓冲的 channel 发送数据的时候，只有在缓冲区满的时候才会阻塞。 而当缓冲区为空的时候接收操作会阻塞。</p></li>

<li><p>修改例子使得缓冲区被填满，然后看看会发生什么
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func main() {
    ch := make(chan int, 2)
    ch &lt;- 1
    ch &lt;- 2
    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
}
`</pre></p></li>

<li><p>结果：
<pre>`1</p>

<h2 id="2">2</h2>

<hr />

<p>fatal error: all goroutines are asleep - deadlock!</p>

<p>goroutine 1 [chan send]:
main.main()
        /tmp/sandbox156608315/main.go:9 +0x100
`</pre></p>

<hr />

<h5 id="4-range-和-close">4.range 和 close</h5></li>

<li><p>发送者可以 close一个 channel 来表示再没有值会被发送了。接收者可以通过赋值语句的第二参数来测试 channel 是否被关闭：当没有值可以接收并且 channel 已经被关闭，那么经过</p></li>

<li><p><code>v, ok := &amp;lt;-ch</code></p></li>

<li><p>之后 ok会被设置为 false。</p></li>

<li><p>循环 <code>for i := range c</code> 会不断从 channel 接收值，直到它被关闭。</p></li>

<li><p><em>注意：</em> 只有发送者才能关闭 channel，而不是接收者。向一个已经关闭的 channel 发送数据会引起 panic。 <em>还要注意：</em> channel 与文件不同；通常情况下无需关闭它们。只有在需要告诉接收者没有更多的数据的时候才有必要进行关闭，例如中断一个 range。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
)</p>

<p>func fibonacci(n int, c chan int) {
    x, y := 0, 1
    for i := 0; i &lt; n; i++ {
        c &lt;- x
        x, y = y, x+y
    }
    close&copy;
}</p>

<p>func main() {
    c := make(chan int, 10)
    go fibonacci(cap&copy;, c)
    for i := range c {
        fmt.Println(i)
    }
}
`</pre></p></li>

<li><p>结果：
<pre><code>0
1
1
2
3
5
8
13
21
34
</code></pre></p>

<hr />

<h5 id="5-select">5.select</h5></li>

<li><p>select语句使得一个 goroutine 在多个通讯操作上等待。</p></li>

<li><p>select会阻塞，直到条件分支中的某个可以继续执行，这时就会执行那个条件分支。当多个都准备好的时候，会随机选择一个
<pre>`package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case c &lt;- x:
            x, y = y, x+y
        case &lt;-quit:
            fmt.Println(&ldquo;quit&rdquo;)
            return
        }
    }
}</p>

<p>func main() {
    c := make(chan int)
    quit := make(chan int)
    go func() {
        for i := 0; i &lt; 10; i++ {
            fmt.Println(&lt;-c)
        }
        quit &lt;- 0
    }()
    fibonacci(c, quit)
}
`</pre></p></li>

<li><p>结果：
<pre><code>0
1
1
2
3
5
8
13
21
34
quit
</code></pre></p>

<hr />

<h5 id="6-默认选择">6.默认选择</h5></li>

<li><p>当 select中的其他条件分支都没有准备好的时候，default分支会被执行。</p></li>

<li><p>为了非阻塞的发送或者接收，可使用 default分支：
<pre><code>select {
case i := &amp;lt;-c: 
    // 使用 idefault: 
    // 从 c 读取会阻塞
}
</code></pre>
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;time&rdquo;
)</p>

<p>func main() {
    tick := time.Tick(100 * time.Millisecond)
    boom := time.After(500 * time.Millisecond)
    for {
        select {
        case &lt;-tick:
            fmt.Println(&ldquo;tick.&rdquo;)
        case &lt;-boom:
            fmt.Println(&ldquo;BOOM!&rdquo;)
            return
        default:
            fmt.Println(&rdquo;    .&ldquo;)
            time.Sleep(50 * time.Millisecond)
        }
    }
}
`</pre></p></li>

<li><p>结果：
<pre><code>.
    .
tick.
    .
    .
tick.
    .
    .
tick.
    .
    .
tick.
    .
    .
tick.
BOOM!
</code></pre></p>

<hr />

<h5 id="7-sync-mutex">7.sync.Mutex</h5></li>

<li><p>我们已经看到 channel用来在各个 goroutine 间进行通信是非常合适的了。</p></li>

<li><p>但是如果我们并不需要通信呢？比如说，如果我们只是想保证在每个时刻，只有一个 goroutine 能访问一个共享的变量从而避免冲突？</p></li>

<li><p>这里涉及的概念叫做 _互斥_，通常使用 <em>互斥锁</em>(mutex)_来提供这个限制。</p></li>

<li><p>Go 标准库中提供了 <a href="https://link.jianshu.com?t=https://go-zh.org/pkg/sync/#Mutex">sync.Mutex</a> 类型及其两个方法：</p>

<pre><code>*   Lock
</code></pre>

<ul>
<li>Unlock</li>
</ul></li>

<li><p>我们可以通过在代码前调用 Lock方法，在代码后调用 Unlock方法来保证一段代码的互斥执行。 参见 Inc方法。</p></li>

<li><p>我们也可以用 defer语句来保证互斥锁一定会被解锁。参见 Value方法。
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
    &ldquo;sync&rdquo;
    &ldquo;time&rdquo;
)</p>

<p>// SafeCounter 的并发使用是安全的。
type SafeCounter struct {
    v   map[string]int
    mux sync.Mutex
}</p>

<p>// Inc 增加给定 key 的计数器的值。
func (c *SafeCounter) Inc(key string) {
    c.mux.Lock()
    // Lock 之后同一时刻只有一个 goroutine 能访问 c.v
    c.v[key]++
    c.mux.Unlock()
}</p>

<p>// Value 返回给定 key 的计数器的当前值。
func (c *SafeCounter) Value(key string) int {
    c.mux.Lock()
    // Lock 之后同一时刻只有一个 goroutine 能访问 c.v
    defer c.mux.Unlock()
    return c.v[key]
}</p>

<p>func main() {
    c := SafeCounter{v: make(map[string]int)}
    for i := 0; i &lt; 1000; i++ {
        go c.Inc(&ldquo;somekey&rdquo;)
    }</p>

<pre><code>time.Sleep(time.Second)
fmt.Println(c.Value(&quot;somekey&quot;))
</code></pre>

<p>}
`</pre></p></li>

<li><p>结果：
<pre><code>1000
</code></pre></p>

<hr />

<h5 id="8-练习-web-爬虫">8.练习：Web 爬虫</h5></li>

<li><p>在这个练习中，将会使用 Go 的并发特性来并行执行 web 爬虫。</p></li>

<li><p>修改 Crawl函数来并行的抓取 URLs，并且保证不重复。</p></li>

<li><p>_提示_：你可以用一个 map 来缓存已经获取的 URL，但是需要注意 map 本身并不是并发安全的！
<pre>`package main</p>

<p>import (
    &ldquo;fmt&rdquo;
)</p>

<p>type Fetcher interface {
    // Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。
    Fetch(url string) (body string, urls []string, err error)
}</p>

<p>// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。
func Crawl(url string, depth int, fetcher Fetcher) {
    // TODO: 并行的抓取 URL。
    // TODO: 不重复抓取页面。
        // 下面并没有实现上面两种情况：
    if depth &lt;= 0 {
        return
    }
    body, urls, err := fetcher.Fetch(url)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Printf(&ldquo;found: %s %q\n&rdquo;, url, body)
    for _, u := range urls {
        Crawl(u, depth-1, fetcher)
    }
    return
}</p>

<p>func main() {
    Crawl(&ldquo;<a href="http://golang.org/&quot;">http://golang.org/&quot;</a>, 4, fetcher)
}</p>

<p>// fakeFetcher 是返回若干结果的 Fetcher。
type fakeFetcher map[string]*fakeResult</p>

<p>type fakeResult struct {
    body string
    urls []string
}</p>

<p>func (f fakeFetcher) Fetch(url string) (string, []string, error) {
    if res, ok := f[url]; ok {
        return res.body, res.urls, nil
    }
    return &ldquo;&rdquo;, nil, fmt.Errorf(&ldquo;not found: %s&rdquo;, url)
}</p>

<p>// fetcher 是填充后的 fakeFetcher。
var fetcher = fakeFetcher{
    &ldquo;<a href="http://golang.org/&quot;:">http://golang.org/&quot;:</a> &amp;fakeResult{
        &ldquo;The Go Programming Language&rdquo;,
        []string{
            &ldquo;<a href="http://golang.org/pkg/&quot;">http://golang.org/pkg/&quot;</a>,
            &ldquo;<a href="http://golang.org/cmd/&quot;">http://golang.org/cmd/&quot;</a>,
        },
    },
    &ldquo;<a href="http://golang.org/pkg/&quot;:">http://golang.org/pkg/&quot;:</a> &amp;fakeResult{
        &ldquo;Packages&rdquo;,
        []string{
            &ldquo;<a href="http://golang.org/&quot;">http://golang.org/&quot;</a>,
            &ldquo;<a href="http://golang.org/cmd/&quot;">http://golang.org/cmd/&quot;</a>,
            &ldquo;<a href="http://golang.org/pkg/fmt/&quot;">http://golang.org/pkg/fmt/&quot;</a>,
            &ldquo;<a href="http://golang.org/pkg/os/&quot;">http://golang.org/pkg/os/&quot;</a>,
        },
    },
    &ldquo;<a href="http://golang.org/pkg/fmt/&quot;:">http://golang.org/pkg/fmt/&quot;:</a> &amp;fakeResult{
        &ldquo;Package fmt&rdquo;,
        []string{
            &ldquo;<a href="http://golang.org/&quot;">http://golang.org/&quot;</a>,
            &ldquo;<a href="http://golang.org/pkg/&quot;">http://golang.org/pkg/&quot;</a>,
        },
    },
    &ldquo;<a href="http://golang.org/pkg/os/&quot;:">http://golang.org/pkg/os/&quot;:</a> &amp;fakeResult{
        &ldquo;Package os&rdquo;,
        []string{
            &ldquo;<a href="http://golang.org/&quot;">http://golang.org/&quot;</a>,
            &ldquo;<a href="http://golang.org/pkg/&quot;">http://golang.org/pkg/&quot;</a>,
        },
    },
}
`</pre></p></li>

<li><p>结果：
<pre>`found: <a href="http://golang.org/">http://golang.org/</a> &ldquo;The Go Programming Language&rdquo;
found: <a href="http://golang.org/pkg/">http://golang.org/pkg/</a> &ldquo;Packages&rdquo;
found: <a href="http://golang.org/">http://golang.org/</a> &ldquo;The Go Programming Language&rdquo;
found: <a href="http://golang.org/pkg/">http://golang.org/pkg/</a> &ldquo;Packages&rdquo;
not found: <a href="http://golang.org/cmd/">http://golang.org/cmd/</a>
not found: <a href="http://golang.org/cmd/">http://golang.org/cmd/</a>
found: <a href="http://golang.org/pkg/fmt/">http://golang.org/pkg/fmt/</a> &ldquo;Package fmt&rdquo;
found: <a href="http://golang.org/">http://golang.org/</a> &ldquo;The Go Programming Language&rdquo;
found: <a href="http://golang.org/pkg/">http://golang.org/pkg/</a> &ldquo;Packages&rdquo;
found: <a href="http://golang.org/pkg/os/">http://golang.org/pkg/os/</a> &ldquo;Package os&rdquo;
found: <a href="http://golang.org/">http://golang.org/</a> &ldquo;The Go Programming Language&rdquo;
found: <a href="http://golang.org/pkg/">http://golang.org/pkg/</a> &ldquo;Packages&rdquo;
not found: <a href="http://golang.org/cmd/">http://golang.org/cmd/</a></p></li>
</ul>

<hr />
</div>

  <footer class="article-footer">
    
    
    
    
    
    <section class="bordered">
      <header>
        <div class="panel-title">TAGS</div>
      </header>
      <div>
        <ul class="p-terms">
          
          <li><a href="https://sung1011.github.io/tags/go/">go</a></li>
          
        </ul>
      </div>
    </section>
    
    
  </footer>

</article>


    <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "Your Disqus shortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </div>

  <div class="col-md-4">
    
<aside class="l-sidebar">

  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">LATESTS</div>
    </div>
    <div class="list-group">
      
      <a href="https://sung1011.github.io/2017-04-15-xxlove/" class="list-group-item">XX-love</a>
      
      <a href="https://sung1011.github.io/2017-04-14-go-cc/" class="list-group-item">Concurrent-and-parallel</a>
      
      <a href="https://sung1011.github.io/2017-04-13-fd/" class="list-group-item">fd</a>
      
      <a href="https://sung1011.github.io/2017-04-12-golang-nobuff-chan/" class="list-group-item">golang-grammer</a>
      
      <a href="https://sung1011.github.io/2017-04-11-golang-grammer/" class="list-group-item">golang-grammer</a>
      
      <a href="https://sung1011.github.io/2017-04-10-encrypted/" class="list-group-item">encrypted</a>
      
      <a href="https://sung1011.github.io/2017-04-09-how-to-novel/" class="list-group-item">How-to-novel</a>
      
      <a href="https://sung1011.github.io/2017-04-08-vim-sort/" class="list-group-item">Vim-sort</a>
      
      <a href="https://sung1011.github.io/2017-04-07-c-pointer/" class="list-group-item">C-pointer</a>
      
      <a href="https://sung1011.github.io/2017-04-06-php-operation-mode/" class="list-group-item">Php-operation-mode</a>
      
    </div>
  </section>

  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">CATEGORY</div>
    </div>
    <div class="list-group">
      
    </div>
  </section>
  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">TAG</div>
    </div>
    <div class="list-group">
      
      <a href="https://sung1011.github.io/tags/basic" class="list-group-item">basic</a>
      
      <a href="https://sung1011.github.io/tags/go" class="list-group-item">go</a>
      
      <a href="https://sung1011.github.io/tags/linux" class="list-group-item">linux</a>
      
      <a href="https://sung1011.github.io/tags/c" class="list-group-item">c</a>
      
      <a href="https://sung1011.github.io/tags/db" class="list-group-item">db</a>
      
      <a href="https://sung1011.github.io/tags/fd" class="list-group-item">fd</a>
      
      <a href="https://sung1011.github.io/tags/ide" class="list-group-item">ide</a>
      
      <a href="https://sung1011.github.io/tags/love" class="list-group-item">love</a>
      
      <a href="https://sung1011.github.io/tags/nginx" class="list-group-item">nginx</a>
      
      <a href="https://sung1011.github.io/tags/novel" class="list-group-item">novel</a>
      
    </div>
  </section>
  

</aside>


  </div>
</div>

      </div>
    </main>

    <footer class="l-footer">
      <div class="container">
        <p><span class="h-logo">&copy; tickles</span></p>
        <aside>
          <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
          <p><a href="https://github.com/dim0627/hugo_theme_beg">Beg</a> designed by <a href="http://yet.unresolved.xyz/">Daisuke Tsuji</a>.</p>
        </aside>
      </div>
    </footer>

    <script src="//code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

